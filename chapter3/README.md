# C言語とオブジェクト指向

## 概要

C言語でプログラムを書く際によくある

- 数百行あるような関数や点在する同じような処理
- `get2()`や`get3()`のように全体としては同じような関数なのに中の一部だけが異なるためにす数字で区別をしている関数
- なんとか内部処理を共通化できているものの、動作を制御するために大量の引数が必要な関数
- 使用するデータがグローバル変数でつながっていて、独立性が皆無の関数群
- お互いに依存しあっていて、個々にテストするのが困難な関数群

。プログラムを構造化したはずなのになぜか生まれてしまう。

このようなときにデザインパターンを利用できる。デザインパターンはオブジェクト指向言語を前提としているが、うまくやればC言語でも可能。

## Cのモジュール化とオブジェクト指向

### Cとモジュール化

一番単純な実装。stackに利用するデータをグローバル変数として定義し、そのデータを叩くことを前提に`push()`や`pop()`を定義する。またそのimplで利用する`isStackFull()`や`isStackEmpty()`は`static`指定しておき、`stack.c`内部でのみ利用する。しかし複数のstackを利用することはできない。


### 構造体によるデータ構造とロジックの分離

データを構造体にひとまとめにすることで複数のstackを簡単に構築できる。

```cpp
  typedef struct {
    int top;
    const size_t size;
    int *pBuff;
  } Stack;

  bool push(Stack *p, int val);
  bool pop(Stack *p, int *pRet);
```

また以下のようなマクロによりC言語でもC++言語のコンストラクタのような初期化ができる。

```cpp
#define newStack(buf){                          \
    0, sizeof(buf) / sizeof(int), (buf)         \
  }
```

### Cを用いたオブジェクト指向

これからやることは、stackに`push()`する値をチェックするチェッカーを持たせて、特定の条件を満たすものだけを通すこと。まず始めに **特定の範囲内の値だけ通す** チェッカー機能を持たせ、次に **任意の条件を満たすチェッカー機能** へと抽象化する。

一般にチェッカーは
- その値(ここではint)を引数に取り
- boolを返す関数

により実現される(trueを返したらpushできる)。またチェッカーの種類によってはチェック自体にデータが必要になることがある(例えば範囲を指定するときの上限と下限など)。そこでこの関数オブジェクトのようなものをデータへのvoidポインタと関数ポインタを持つ構造体`Validator`により実現する。

#### チェック機能付きスタック

構造体にpushする値の範囲をデータとして持たせて、pushするときに利用する。

#### 範囲チェック付きスタックの問題点

前項でつくったstackは
- 範囲チェックなしのスタックを生成した場合にも`needRangeCheck`や`min`、`max`といったメンバ変数を持つ必要があり、メモリが無駄に消費される
- スタック内にこれとは別のチェック機能を持たせたいと思った時に、さらに別のデータを追加しないといけないため、各インスタンスが使わない機能のためのデータを余計に持つことになる

という問題がある。とりあえずそのデータへのポインタを保持するようにすることで無駄なデータを持たなくて良いようにする。

#### チェック機能を汎用化する

値のチェックを行う機能としては何も上下限だけとは限らない。例えば前回pushした値以上の値しかpushできない(ほんとに？とはなるが例として)ものも考えられる。そういう任意のチェックを行えるよう、より抽象化を行う。

### オブジェクト指向と多態性

オブジェクト指向のポイントは、データとその処理を **両方とも** まとめるところにある。Validatorという構造体の中に検証の処理(関数ポインタvalidate)と、その検証処理が使用するデータ(voidポインタpData)とをセットで切り出すことにより、検証処理が独立し、スタックの中にさまざまな検証処理をあとから付け加えることができるようになった。

オブジェクト指向の要件として他には、多態性が挙げられる。ここまでだと、push関数は値を検証するのにValidator->validateを利用するのみで、validateが実際に指している関数の中身は一切関知していない。

### 継承

オブジェクト指向の重要な概念の一つとして継承がある。先ほどの例だと、もともとのValidatorがあり、それを拡張した(とはいっても関数ポインタを代入しただけだが)範囲チェックValidator、直前の値との検証Validatorという２つのValidatorが存在している。この場合、元々のValidatorのことを親、拡張したValidatorを子と呼ぶ。

先ほどの範囲チェックValidatorではpDataの指す先がRangeになっている。このような方は申し少し複雑になってくると面倒なことになる。例えばこの範囲チェックValidatorを拡張して、偶数あるいは奇数しか受け付けないようなValidatorを作るとする。この場合単純にRangeを拡張してしまうと

```cpp
typedef struct{
    const int min;
    const int max;
    const bool needOddEvenCheck; // trueなら偶奇チェックする
    const boll needToBeEven;     // trueなら奇数でなければいけない
} Range;
```

Rangeの位置づけが曖昧になる。Rangeは「範囲」という意味であるからここに偶奇のチェックが入るのは変だし、そのチェックが不要な場合は余計なメンバを２つ抱えることになってしまう。これをうまく解決するため、継承っぽいことをやってみる。

