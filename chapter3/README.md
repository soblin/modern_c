# C言語とオブジェクト指向

## 概要

C言語でプログラムを書く際によくある

- 数百行あるような関数や点在する同じような処理
- `get2()`や`get3()`のように全体としては同じような関数なのに中の一部だけが異なるためにす数字で区別をしている関数
- なんとか内部処理を共通化できているものの、動作を制御するために大量の引数が必要な関数
- 使用するデータがグローバル変数でつながっていて、独立性が皆無の関数群
- お互いに依存しあっていて、個々にテストするのが困難な関数群

。プログラムを構造化したはずなのになぜか生まれてしまう。

このようなときにデザインパターンを利用できる。デザインパターンはオブジェクト指向言語を前提としているが、うまくやればC言語でも可能。

## Cのモジュール化とオブジェクト指向

### Cとモジュール化

一番単純な実装。stackに利用するデータをグローバル変数として定義し、そのデータを叩くことを前提に`push()`や`pop()`を定義する。またそのimplで利用する`isStackFull()`や`isStackEmpty()`は`static`指定しておき、`stack.c`内部でのみ利用する。しかし複数のstackを利用することはできない。


### 構造体によるデータ構造とロジックの分離

データを構造体にひとまとめにすることで複数のstackを簡単に構築できる。

```cpp
  typedef struct {
    int top;
    const size_t size;
    int *pBuff;
  } Stack;

  bool push(Stack *p, int val);
  bool pop(Stack *p, int *pRet);
```

また以下のようなマクロによりC言語でもC++言語のコンストラクタのような初期化ができる。

```cpp
#define newStack(buf){                          \
    0, sizeof(buf) / sizeof(int), (buf)         \
  }
```

### Cを用いたオブジェクト指向

これからやることは、stackに`push()`する値をチェックするチェッカーを持たせて、特定の条件を満たすものだけを通すこと。まず始めに **特定の範囲内の値だけ通す** チェッカー機能を持たせ、次に **任意の条件を満たすチェッカー機能** へと抽象化する。

一般にチェッカーは
- その値(ここではint)を引数に取り
- boolを返す関数

により実現される(trueを返したらpushできる)。またチェッカーの種類によってはチェック自体にデータが必要になることがある(例えば範囲を指定するときの上限と下限など)。そこでこの関数オブジェクトのようなものをデータへのvoidポインタと関数ポインタを持つ構造体`Validator`により実現する。

#### チェック機能付きスタック

構造体にpushする値の範囲をデータとして持たせて、pushするときに利用する。
